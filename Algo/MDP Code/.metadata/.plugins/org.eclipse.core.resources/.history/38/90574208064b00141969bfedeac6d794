package mdp.algorithm.fastestPath;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;
import java.awt.Point;

import mdp.algorithm.simulator.*;


/**
 * @author      Iryanto Jaya
 * @since       2014-09-07
 */
public class PathSolver {
	private Stack<Point> path1 = new Stack<Point>(); //Path generated by iterativeDeepening1()
	private Stack<Point> path2 = new Stack<Point>(); //Path generated by iterativeDeepening2()
	private Stack<Point> path3 = new Stack<Point>(); //Path generated by bfs1()
	private Stack<Point> path4 = new Stack<Point>(); //Path generated by bfs2()
	private final static int MOVE_WEIGHT = 63; //The weight of moving to the cost
	private final static int TURN_WEIGHT = 160; //The weight of turning left or right to the cost
	private final static int REVERSE_WEIGHT = 210; //The weight of turning backward to the cost
	
	/**
	 * Check if there are obstacles at the North of the robot
	 *
	 * @param  location		The location of the robot
	 * @param  maze			The maze
	 * @return true if obstacle exists, false otherwise
	 */
	public boolean checkObstacleNorth(Point location,Maze maze){
		if(maze.checkObstacle((int) location.getX()-2,(int) location.getY()-1)||
				maze.checkObstacle((int) location.getX()-2,(int) location.getY())||
				maze.checkObstacle((int) location.getX()-2,(int) location.getY()+1))
			return true;
		else
			return false;
	}
	
	/**
	 * Check if there are unexplored squares at the North of the robot
	 *
	 * @param  location		The location of the robot
	 * @param  maze			The maze
	 * @return true if unexplored square exists, false otherwise
	 */
	public boolean checkUnexploredNorth(Point location,Maze maze){
		if(maze.checkUnexplored((int) location.getX()-2,(int) location.getY()-1)||
				maze.checkUnexplored((int) location.getX()-2,(int) location.getY())||
				maze.checkUnexplored((int) location.getX()-2,(int) location.getY()+1))
			return true;
		else
			return false;
	}
	
	/**
	 * Check if there are obstacles at the South of the robot
	 *
	 * @param  location		The location of the robot
	 * @param  maze			The maze
	 * @return true if obstacle exists, false otherwise
	 */
	public boolean checkObstacleSouth(Point location,Maze maze){
		if(maze.checkObstacle((int) location.getX()+2,(int) location.getY()-1)||
				maze.checkObstacle((int) location.getX()+2,(int) location.getY())||
				maze.checkObstacle((int) location.getX()+2,(int) location.getY()+1))
			return true;
		else
			return false;
	}
	
	/**
	 * Check if there are unexplored squares at the South of the robot
	 *
	 * @param  location		The location of the robot
	 * @param  maze			The maze
	 * @return true if unexplored square exists, false otherwise
	 */
	public boolean checkUnexploredSouth(Point location,Maze maze){
		if(maze.checkUnexplored((int) location.getX()+2,(int) location.getY()-1)||
				maze.checkUnexplored((int) location.getX()+2,(int) location.getY())||
				maze.checkUnexplored((int) location.getX()+2,(int) location.getY()+1))
			return true;
		else
			return false;
	}
	
	/**
	 * Check if there are obstacles at the West of the robot
	 *
	 * @param  location		The location of the robot
	 * @param  maze			The maze
	 * @return true if obstacle exists, false otherwise
	 */
	public boolean checkObstacleWest(Point location,Maze maze){
		if(maze.checkObstacle((int) location.getX()+1,(int) location.getY()-2)||
				maze.checkObstacle((int) location.getX(),(int) location.getY()-2)||
				maze.checkObstacle((int) location.getX()-1,(int) location.getY()-2))
			return true;
		else
			return false;
	}
	
	/**
	 * Check if there are unexplored squares at the West of the robot
	 *
	 * @param  location		The location of the robot
	 * @param  maze			The maze
	 * @return true if unexplored squares exists, false otherwise
	 */
	public boolean checkUnexploredWest(Point location,Maze maze){
		if(maze.checkUnexplored((int) location.getX()+1,(int) location.getY()-2)||
				maze.checkUnexplored((int) location.getX(),(int) location.getY()-2)||
				maze.checkUnexplored((int) location.getX()-1,(int) location.getY()-2))
			return true;
		else
			return false;
	}
	
	/**
	 * Check if there are obstacles at the East of the robot
	 *
	 * @param  location		The location of the robot
	 * @param  maze			The maze
	 * @return true if obstacle exists, false otherwise
	 */
	public boolean checkObstacleEast(Point location,Maze maze){
		if(maze.checkObstacle((int) location.getX()+1,(int) location.getY()+2)||
				maze.checkObstacle((int) location.getX(),(int) location.getY()+2)||
				maze.checkObstacle((int) location.getX()-1,(int) location.getY()+2))
			return true;
		else
			return false;
	}
	
	/**
	 * Check if there are unexplored squares at the East of the robot
	 *
	 * @param  location		The location of the robot
	 * @param  maze			The maze
	 * @return true if unexplored square exists, false otherwise
	 */
	public boolean checkUnexploredEast(Point location,Maze maze){
		if(maze.checkUnexplored((int) location.getX()+1,(int) location.getY()+2)||
				maze.checkUnexplored((int) location.getX(),(int) location.getY()+2)||
				maze.checkUnexplored((int) location.getX()-1,(int) location.getY()+2))
			return true;
		else
			return false;
	}
	
	/**
	 * Using iterative deepening search or BFS to look for the path from the start to the goal
	 * <p>
	 * The minimum depth is 29 since there is no solvable path with less than 29 steps
	 *
	 * @param  root		The starting node
	 * @param  goal		The goal node
	 * @param  maze		The maze
	 * @param  ori		The starting orientation of the robot
	 * @return The path that leads from the start to the goal
	 */
	public Stack<Point> solvePath(Point root,Point goal,Maze maze,int ori){
		maze.initializeArduinoCommand("AS");
		int cost1; //Cost to follow path1
		int cost2; //Cost to follow path2
		int cost3; //Cost to follow path3
		int cost4; //Cost to follow path4
		//Set the path and cost according to the algorithm
		cost1 = iterativeDeepening1(root,goal,maze,ori);
		cost2 = iterativeDeepening2(root,goal,maze,ori);
		cost3 = bfs1(root,goal,maze,ori);
		cost4 = bfs2(root,goal,maze,ori);
		
		//Choose the path with the smallest cost
		if(cost1<cost2){
			if(cost3<cost4){
				if(cost1<cost3)
					return path1;
				else
					return path3;
			}
			else{
				if(cost1<cost4)
					return path1;
				else
					return path4;
			}
		}
		else{
			if(cost3<cost4){
				if(cost2<cost3)
					return path2;
				else
					return path3;
			}
			else{
				if(cost2<cost4)
					return path2;
				else
					return path4;
			}
			
		}
	}
	
	/**
	 * Use BFS to search for goal (prefer North to East)
	 *
	 * @param  start		The starting node
	 * @param  goal			The goal node
	 * @param  maze			The maze
	 * @param  ori			The orientation of the robot
	 * @return The cost to execute the path
	 */
	public int bfs1(Point start, Point goal,Maze maze,int ori){
		int prevOri;
		int turn = 0;
		int move = 0;
		int reverse = 0;
		Point tempPoint = new Point();
		Queue<Point> visited = new LinkedList<Point>();
		Queue<Point> bfsQueue = new LinkedList<Point>();
		HashMap<Point,Point> childParent = new HashMap<Point,Point>();
		Point current = start;
		while(!current.equals(goal)){
			visited.add(current);
			//Check North
			if(current.getX()>2){
				tempPoint.setLocation(current.getX()-1,current.getY());
				if(!checkObstacleNorth(current, maze)&&!checkUnexploredNorth(current,maze)&&!visited.contains(tempPoint)&&!bfsQueue.contains(tempPoint)){
					childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
					bfsQueue.add(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
			//Check East
			if(current.getY()<14){
				tempPoint.setLocation(current.getX(),current.getY()+1);
				if(!checkObstacleEast(current, maze)&&!checkUnexploredEast(current,maze)&&!visited.contains(tempPoint)&&!bfsQueue.contains(tempPoint)){
					childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
					bfsQueue.add(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
			//Check South
			if(current.getX()<19){
				tempPoint.setLocation(current.getX()+1,current.getY());
				if(!checkObstacleSouth(current, maze)&&!checkUnexploredSouth(current,maze)&&!visited.contains(tempPoint)&&!bfsQueue.contains(tempPoint)){
					childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
					bfsQueue.add(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
			//Check West
			if(current.getY()>2){
				tempPoint.setLocation(current.getX(),current.getY()-1);
				if(!checkObstacleWest(current, maze)&&!checkUnexploredWest(current,maze)&&!visited.contains(tempPoint)&&!bfsQueue.contains(tempPoint)){
					childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
					bfsQueue.add(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
			current = bfsQueue.poll();
			
			//Nowhere to move
			if(current==null)
				return 9999;
			
			move++;
			prevOri = ori;
			if(current.getY()-tempPoint.getY()==-1)
				ori = 0;
			if(current.getX()-tempPoint.getX()==1)
				ori = 1;
			if(current.getY()-tempPoint.getY()==1)
				ori = 2;
			if(current.getX()-tempPoint.getX()==-1)
				ori = 3;
			if((prevOri-ori)*(prevOri-ori)==4)
				reverse++;
			else if((prevOri-ori)!=0)
				turn++;
		}
		
		path3.push(goal);
		tempPoint.setLocation(goal.getX(),goal.getY());
		while(!tempPoint.equals(start)){
			for(Point p : childParent.keySet()){
				if(tempPoint.equals(p)){
					tempPoint.setLocation(childParent.get(tempPoint).getX(),childParent.get(tempPoint).getY());
					path3.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
		}
		return MOVE_WEIGHT*move + TURN_WEIGHT*turn + REVERSE_WEIGHT*reverse;
	}
	
	/**
	 * Use BFS to search for goal (prefer East to North)
	 *
	 * @param  start		The starting node
	 * @param  goal			The goal node
	 * @param  maze			The maze
	 * @param  ori			The orientation of the robot
	 * @return The cost to execute the path
	 */
	public int bfs2(Point start, Point goal,Maze maze,int ori){
		int turn = 0;
		int move = 0;
		int reverse = 0;
		int prevOri;
		Point tempPoint = new Point();
		Queue<Point> visited = new LinkedList<Point>();
		Queue<Point> bfsQueue = new LinkedList<Point>();
		HashMap<Point,Point> childParent = new HashMap<Point,Point>();
		Point current = start;
		while(!current.equals(goal)){
			visited.add(current);
			//Check East
			if(current.getY()<14){
				tempPoint.setLocation(current.getX(),current.getY()+1);
				if(!checkObstacleEast(current, maze)&&!checkUnexploredEast(current,maze)&&!visited.contains(tempPoint)&&!bfsQueue.contains(tempPoint)){
					childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
					bfsQueue.add(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
			//Check North
			if(current.getX()>2){
				tempPoint.setLocation(current.getX()-1,current.getY());
				if(!checkObstacleNorth(current, maze)&&!checkUnexploredNorth(current,maze)&&!visited.contains(tempPoint)&&!bfsQueue.contains(tempPoint)){
					childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
					bfsQueue.add(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
			//Check South
			if(current.getX()<19){
				tempPoint.setLocation(current.getX()+1,current.getY());
				if(!checkObstacleSouth(current, maze)&&!checkUnexploredSouth(current,maze)&&!visited.contains(tempPoint)&&!bfsQueue.contains(tempPoint)){
					childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
					bfsQueue.add(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
			//Check West
			if(current.getY()>2){
				tempPoint.setLocation(current.getX(),current.getY()-1);
				if(!checkObstacleWest(current, maze)&&!checkUnexploredWest(current,maze)&&!visited.contains(tempPoint)&&!bfsQueue.contains(tempPoint)){
					childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
					bfsQueue.add(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
			current = bfsQueue.poll();

			//Nowhere to move
			if(current==null)
				return 9999;
			
			move++;
			prevOri = ori;
			if(current.getY()-tempPoint.getY()==-1)
				ori = 0;
			if(current.getX()-tempPoint.getX()==1)
				ori = 1;
			if(current.getY()-tempPoint.getY()==1)
				ori = 2;
			if(current.getX()-tempPoint.getX()==-1)
				ori = 3;
			if((prevOri-ori)*(prevOri-ori)==4)
				reverse++;
			else if((prevOri-ori)!=0)
				turn++;
		}
		
		path4.push(goal);
		tempPoint.setLocation(goal.getX(),goal.getY());
		while(!tempPoint.equals(start)){
			for(Point p : childParent.keySet()){
				if(tempPoint.equals(p)){
					tempPoint.setLocation(childParent.get(tempPoint).getX(),childParent.get(tempPoint).getY());
					path4.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
		}
		return MOVE_WEIGHT*move + TURN_WEIGHT*turn + REVERSE_WEIGHT*reverse;
	}
	
	/**
	 * Use iterative deepening to search for goal (prefer North to East)
	 *
	 * @param  start		The starting node
	 * @param  goal			The goal node
	 * @param  maze			The maze
	 * @param  ori			The orientation of the robot
	 * @return The cost to execute the path
	 */
	public int iterativeDeepening1(Point start,Point goal,Maze maze,int ori){
		int initialDepth = 29;
		int depth = initialDepth;
		int prevOri;
		int turn = 0;
		int move = 0;
		int reverse = 0;
		Point tempPoint = new Point();
		Queue<Point> visited = new LinkedList<Point>();
		Stack<Point> dfsStack = new Stack<Point>();
		HashMap<Point,Point> childParent = new HashMap<Point,Point>();
		Point current = start;
		
		while(!current.equals(goal)){
			current = start;
			childParent.clear();
			while(depth>0){
				visited.add(current);
				if(ori==0||ori==3){
					//Check South
					if(current.getX()<19){
						tempPoint.setLocation(current.getX()+1,current.getY());
						if(!checkObstacleSouth(current, maze)&&!checkUnexploredSouth(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
							childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
							dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
						}
					}
					//Check West
					if(current.getY()>2){
						tempPoint.setLocation(current.getX(),current.getY()-1);
						if(!checkObstacleWest(current, maze)&&!checkUnexploredWest(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
							childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
							dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
						}
					}
					//Check East
					if(current.getY()<14){
						tempPoint.setLocation(current.getX(),current.getY()+1);
						if(!checkObstacleEast(current, maze)&&!checkUnexploredEast(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
							childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
							dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
						}
					}
					//Check North
					if(current.getX()>2){
						tempPoint.setLocation(current.getX()-1,current.getY());
						if(!checkObstacleNorth(current, maze)&&!checkUnexploredNorth(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
							childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
							dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
						}
					}
				}
				else{
					//Check South
					if(current.getX()<19){
						tempPoint.setLocation(current.getX()+1,current.getY());
						if(!checkObstacleSouth(current, maze)&&!checkUnexploredSouth(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
							childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
							dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
						}
					}
					//Check West
					if(current.getY()>2){
						tempPoint.setLocation(current.getX(),current.getY()-1);
						if(!checkObstacleWest(current, maze)&&!checkUnexploredWest(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
							childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
							dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
						}
					}
					//Check North
					if(current.getX()>2){
						tempPoint.setLocation(current.getX()-1,current.getY());
						if(!checkObstacleNorth(current, maze)&&!checkUnexploredNorth(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
							childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
							dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
						}
					}
					//Check East
					if(current.getY()<14){
						tempPoint.setLocation(current.getX(),current.getY()+1);
						if(!checkObstacleEast(current, maze)&&!checkUnexploredEast(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
							childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
							dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
						}
					}
				}
				depth--;
				tempPoint.setLocation(current.getX(),current.getY());
				if(dfsStack.empty())
					break;
				
				current = dfsStack.pop();

				//Nowhere to move
				if(current==null)
					return 9999;
				
				move++;
				prevOri = ori;
				if(current.getY()-tempPoint.getY()==-1)
					ori = 0;
				if(current.getX()-tempPoint.getX()==1)
					ori = 1;
				if(current.getY()-tempPoint.getY()==1)
					ori = 2;
				if(current.getX()-tempPoint.getX()==-1)
					ori = 3;
				if((prevOri-ori)*(prevOri-ori)==4)
					reverse++;
				else if((prevOri-ori)!=0)
					turn++;
			}
			visited.clear();
			dfsStack.clear();
			initialDepth++;
			depth = initialDepth;
			if(initialDepth==50){
				path1.clear();
				return 9999;
			}
		}

		path1.push(goal);
		tempPoint.setLocation(goal.getX(),goal.getY());
		while(!tempPoint.equals(start)){
			for(Point p : childParent.keySet()){
				if(tempPoint.equals(p)){
					tempPoint.setLocation(childParent.get(tempPoint).getX(),childParent.get(tempPoint).getY());
					path1.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
		}
		return MOVE_WEIGHT*move + TURN_WEIGHT*turn + REVERSE_WEIGHT*reverse;
	}
	
	/**
	 * Use iterative deepening to search for goal (prefer East to North)
	 *
	 * @param  start		The starting node
	 * @param  goal			The goal node
	 * @param  maze			The maze
	 * @param  ori			The orientation of the robot
	 * @return The cost to execute the path
	 */
	public int iterativeDeepening2(Point start,Point goal,Maze maze,int ori){
		int initialDepth = 29;
		int depth = initialDepth;
		int prevOri;
		int turn = 0;
		int move = 0;
		int reverse = 0;
		Point tempPoint = new Point();
		Queue<Point> visited = new LinkedList<Point>();
		Stack<Point> dfsStack = new Stack<Point>();
		HashMap<Point,Point> childParent = new HashMap<Point,Point>();
		Point current = start;
		
		while(!current.equals(goal)){
			current = start;
			childParent.clear();
			while(depth>0){
				visited.add(current);
				if(depth==initialDepth){
					//Check East
					if(current.getY()<14){
						tempPoint.setLocation(current.getX(),current.getY()+1);
						if(!checkObstacleEast(current, maze)&&!checkUnexploredEast(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
							childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
							dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
						}
					}
				}
				else{
					if(ori==0||ori==3){
						//Check South
						if(current.getX()<19){
							tempPoint.setLocation(current.getX()+1,current.getY());
							if(!checkObstacleSouth(current, maze)&&!checkUnexploredSouth(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
								childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
								dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
							}
						}
						//Check West
						if(current.getY()>2){
							tempPoint.setLocation(current.getX(),current.getY()-1);
							if(!checkObstacleWest(current, maze)&&!checkUnexploredWest(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
								childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
								dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
							}
						}
						//Check East
						if(current.getY()<14){
							tempPoint.setLocation(current.getX(),current.getY()+1);
							if(!checkObstacleEast(current, maze)&&!checkUnexploredEast(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
								childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
								dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
							}
						}
						//Check North
						if(current.getX()>2){
							tempPoint.setLocation(current.getX()-1,current.getY());
							if(!checkObstacleNorth(current, maze)&&!checkUnexploredNorth(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
								childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
								dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
							}
						}
					}
					else{
						//Check South
						if(current.getX()<19){
							tempPoint.setLocation(current.getX()+1,current.getY());
							if(!checkObstacleSouth(current, maze)&&!checkUnexploredSouth(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
								childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
								dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
							}
						}
						//Check West
						if(current.getY()>2){
							tempPoint.setLocation(current.getX(),current.getY()-1);
							if(!checkObstacleWest(current, maze)&&!checkUnexploredWest(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
								childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
								dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
							}
						}
						//Check North
						if(current.getX()>2){
							tempPoint.setLocation(current.getX()-1,current.getY());
							if(!checkObstacleNorth(current, maze)&&!checkUnexploredNorth(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
								childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
								dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
							}
						}
						//Check East
						if(current.getY()<14){
							tempPoint.setLocation(current.getX(),current.getY()+1);
							if(!checkObstacleEast(current, maze)&&!checkUnexploredEast(current,maze)&&!visited.contains(tempPoint)&&!dfsStack.contains(tempPoint)){
								childParent.put(new Point((int) tempPoint.getX(),(int) tempPoint.getY()),current);
								dfsStack.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
							}
						}
					}
				}
				depth--;
				tempPoint.setLocation(current.getX(),current.getY());
				if(dfsStack.empty())
					break;
				
				current = dfsStack.pop();

				//Nowhere to move
				if(current==null)
					return 9999;
				
				move++;
				prevOri = ori;
				if(current.getY()-tempPoint.getY()==-1)
					ori = 0;
				if(current.getX()-tempPoint.getX()==1)
					ori = 1;
				if(current.getY()-tempPoint.getY()==1)
					ori = 2;
				if(current.getX()-tempPoint.getX()==-1)
					ori = 3;
				if((prevOri-ori)*(prevOri-ori)==4)
					reverse++;
				else if((prevOri-ori)!=0)
					turn++;
			}
			visited.clear();
			dfsStack.clear();
			initialDepth++;
			depth = initialDepth;
			if(initialDepth==50){
				path2.clear();
				return 9999;
			}
		}

		path2.push(goal);
		tempPoint.setLocation(goal.getX(),goal.getY());
		while(!tempPoint.equals(start)){
			for(Point p : childParent.keySet()){
				if(tempPoint.equals(p)){
					tempPoint.setLocation(childParent.get(tempPoint).getX(),childParent.get(tempPoint).getY());
					path2.push(new Point((int) tempPoint.getX(),(int) tempPoint.getY()));
				}
			}
		}
		return MOVE_WEIGHT*move + TURN_WEIGHT*turn + REVERSE_WEIGHT*reverse;
	}
	
	/**
	 * Move the robot after the search
	 * <p>
	 * The search result is obtained from the iterative deepening search
	 *
	 * @param  path   		The path from start to goal
	 * @param  current		The current position of the robot, set to starting point when calling this method
	 * @param  maze			The maze
	 */
	public void moveRobot(Stack<Point> path,Point current,Point goal,Maze maze, int ori){
		Point tempPoint = new Point();
		
		//The robot cannot move if there is no possible path
		if(path.empty()){
			System.out.println("No possible path");
			return;
		}
		
		//We don't need the root
		path.pop();
		
		while(!tempPoint.equals(goal)){
			if(ori==4)
				ori = 0;
			if(ori==-1)
				ori = 3;
			
			tempPoint = path.pop();
			
			//If the next point is below the current point
			if((tempPoint.getX()-current.getX()==1)&&(tempPoint.getY()-current.getY()==0)){
				switch(ori){
					case 0 : maze.spinBackward();
							 maze.moveForward();
							 ori = 2;
							 break;
					case 2 : maze.moveForward();
					 		 break;
					case 3 : maze.spinLeft(); 
							 maze.moveForward();
							 ori = 2;
					 		 break;
					case 1 : maze.spinRight(); 
							 maze.moveForward();
							 ori = 2;
					 		 break;
				}
			}
			
			//If the next point is above the current point
			if((tempPoint.getX()-current.getX()==-1)&&(tempPoint.getY()-current.getY()==0)){
				switch(ori){
					case 0 : maze.moveForward();
							 break;
					case 2 : maze.spinBackward();
							 maze.moveForward();
							 ori = 0;
							 break;
					case 3 : maze.spinRight(); 
							 maze.moveForward();
							 ori = 0;
					 		 break;
					case 1 : maze.spinLeft(); 
							 maze.moveForward();
							 ori = 0;
					 		 break;
				}
			}
			
			//If the next point is on the East of the current point
			if((tempPoint.getX()-current.getX()==0)&&(tempPoint.getY()-current.getY()==1)){
				switch(ori){
					case 0 : maze.spinRight(); 
							 maze.moveForward();
							 ori = 1;
					 		 break;
					case 2 : maze.spinLeft(); 
							 maze.moveForward();
							 ori = 1;
					 		 break;
					case 3 : maze.spinBackward();
							 maze.moveForward();
							 ori = 1;
			 		 		 break;
					case 1 : maze.moveForward();
							 break;
				}
			}
			
			//If the next point is on the West of the current point
			if((tempPoint.getX()-current.getX()==0)&&(tempPoint.getY()-current.getY()==-1)){
				switch(ori){
					case 0 : maze.spinLeft();
							 maze.moveForward();
							 ori = 3;
					 		 break;
					case 2 : maze.spinRight();
							 maze.moveForward();
							 ori = 3;
					 		 break;
					case 3 : maze.moveForward();
							 break;
					case 1 : maze.spinBackward();
							 maze.moveForward();
							 ori = 3;
							 break;
				}
			}
			
			//Update the current position
			current.setLocation(tempPoint.getX(),tempPoint.getY());
		}
		//ending point
	}
}