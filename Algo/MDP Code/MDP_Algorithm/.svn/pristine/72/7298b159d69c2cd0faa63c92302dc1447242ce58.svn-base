package mdp.algorithm.simulator;

import java.awt.Color;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.Timer;

public class Maze extends JPanel{
	private static final int ROWS = 22;
	private static final int COLUMNS = 17;
	
	private static final Color DEFAULT = new Color(198,217,241);
	private static final Color OBSTACLES = new Color(64,64,64);
	private static final Color OBSTACLESFOUND = new Color(20,255,0);
	private static final Color GOALSTART = Color.WHITE;
	private static final Color EXPLORED = new Color(255,255,102);
	private static final Color ROBOT = new Color(146,208,80);
	private static final Color ROBOTFRONT = Color.RED;
	
	private static final int NORTH = 0, EAST = 1, SOUTH = 2, WEST = 3;
	private static int robotMidPointRow = 3;
	private static int robotMidPointCol = 3;
	private static int robotOrientation = NORTH;
	private static int robotFrontRow = robotMidPointRow - 1;
	private static int robotFrontCol = robotMidPointRow;
	
	JPanel[][] grid = new JPanel[ROWS][COLUMNS];
	JLabel[][] cells = new JLabel[ROWS][COLUMNS];
	
	TimerQueue queue = new TimerQueue();
	
	Timer timer;
	
	public Maze(){
		mazeUI();
		robot();
	}
	
	public void resetMap(){
		int oldRobotMidPointRow = robotMidPointRow;
		int oldRobotMidPointCol = robotMidPointCol;
		robotMidPointRow = 2;
		robotMidPointCol = 2;
		robotOrientation = NORTH;
		robotFrontRow = robotMidPointRow - 1;
		robotFrontCol = robotMidPointRow;
		clearRobot(oldRobotMidPointRow, oldRobotMidPointCol);
		robot();
		
		for (int i = 0;i<ROWS;i++){
        	for (int j = 0;j<COLUMNS;j++){
        		if(!(i==0 || i==21 || j==0 || j==16)){
	        		if(grid[i][j].getBackground() == OBSTACLES || grid[i][j].getBackground() == EXPLORED || grid[i][j].getBackground() == OBSTACLESFOUND){
	        			grid[i][j].setBackground(DEFAULT);
	        		}
	        	}
        	}
		}
		
	}
	
	private void actionToBeTaken(){
		char item;
		if(queue.getQueueSize() > 0){
			item = queue.dequeueItem();
	  		switch(item){
	  		case 'f':
				moveForwardAction();
				break;
	  		case 'b':
				moveBackwardAction();
				break;
	  		case 'r':
				spinRightAction();
				break;
	  		case 'l':
				spinLeftAction();
				break;
	  		case 'e':
	  			setExplorationPathAction();
				break;
			}
		}
	}
	
	private void mazeUI(){
        setLayout(new GridLayout(ROWS, COLUMNS, 3, 3));
    	
        for (int i = 0;i<ROWS;i++){
        	for (int j = 0;j<COLUMNS;j++){
        		JPanel newCell = new JPanel();
        		//Colour cells
        		if(((i==1 || i==2 || i==3) && (j==13 || j==14 || j==15)) || ((i==18 || i==19 || i==20) && (j==1 || j==2 || j==3)))
        			newCell.setBackground(GOALSTART);
        		else if(i==0 || i==21 || j==0 || j==16)
        			newCell.setBackground(OBSTACLES);
        		else{
        			newCell.setBackground(DEFAULT);
        		
	        		//onClick
					newCell.addMouseListener(new MouseAdapter() {
		               	@Override
		               	public void mouseClicked(MouseEvent e) {
		               		JPanel clickedPanel = (JPanel) e.getSource();
		               		if(clickedPanel.getBackground() == DEFAULT)
		               			clickedPanel.setBackground(OBSTACLES);
		               		else if(clickedPanel.getBackground() == OBSTACLES)
		               			clickedPanel.setBackground(DEFAULT);
		                }
		             });
				}
        		grid[i][j] = newCell;
				cells[i][j] = new JLabel();
        		
				grid[i][j].add(cells[i][j]);
				add(newCell);
	        }
        }
	}
	
	private void robot(){
		grid[robotMidPointRow-1][robotMidPointCol-1].setBackground(ROBOT);
		grid[robotMidPointRow][robotMidPointCol-1].setBackground(ROBOT);
		grid[robotMidPointRow-1][robotMidPointCol].setBackground(ROBOT);
		grid[robotMidPointRow-1][robotMidPointCol+1].setBackground(ROBOT);
		grid[robotMidPointRow][robotMidPointCol].setBackground(ROBOT);
		grid[robotMidPointRow+1][robotMidPointCol+1].setBackground(ROBOT);
		grid[robotMidPointRow+1][robotMidPointCol].setBackground(ROBOT);
		grid[robotMidPointRow][robotMidPointCol+1].setBackground(ROBOT);
		grid[robotMidPointRow+1][robotMidPointCol-1].setBackground(ROBOT);
		shadeFront();
	}
	
	//The robot moves one step forward according to its orientation
	private void moveForwardAction(){
		switch(robotOrientation){
		case 0: 
			if(robotMidPointRow > 2){
				robotMidPointRow--;
				robot();
				grid[robotMidPointRow+2][robotMidPointCol].setBackground(EXPLORED);
				grid[robotMidPointRow+2][robotMidPointCol+1].setBackground(EXPLORED);
				grid[robotMidPointRow+2][robotMidPointCol-1].setBackground(EXPLORED);
			}
			else
				System.out.println("WALL!");
			break;
		case 1:
			if(robotMidPointCol < 14){
				robotMidPointCol++;
				robot();
				grid[robotMidPointRow-1][robotMidPointCol-2].setBackground(EXPLORED);
				grid[robotMidPointRow][robotMidPointCol-2].setBackground(EXPLORED);
				grid[robotMidPointRow+1][robotMidPointCol-2].setBackground(EXPLORED);
			}
			else
				System.out.println("WALL!");
			break;
		case 2:
			if(robotMidPointRow < 19){
				robotMidPointRow++;
				robot();
				grid[robotMidPointRow-2][robotMidPointCol-1].setBackground(EXPLORED);
				grid[robotMidPointRow-2][robotMidPointCol].setBackground(EXPLORED);
				grid[robotMidPointRow-2][robotMidPointCol+1].setBackground(EXPLORED);
			}
			else
				System.out.println("WALL!");
			break;
		case 3:
			if(robotMidPointCol > 2){
				robotMidPointCol--;
				robot();
				grid[robotMidPointRow-1][robotMidPointCol+2].setBackground(EXPLORED);
				grid[robotMidPointRow][robotMidPointCol+2].setBackground(EXPLORED);
				grid[robotMidPointRow+1][robotMidPointCol+2].setBackground(EXPLORED);
			}
			else
				System.out.println("WALL!");
			break;
		}
	}
	
	//The robot moves one step backward according to its orientation
	private void moveBackwardAction(){
		switch(robotOrientation){
		case 0: 
			if(robotMidPointRow < 19){
				robotMidPointRow++;
				robot();
				grid[robotMidPointRow-2][robotMidPointCol-1].setBackground(EXPLORED);
				grid[robotMidPointRow-2][robotMidPointCol].setBackground(EXPLORED);
				grid[robotMidPointRow-2][robotMidPointCol+1].setBackground(EXPLORED);
			}
			else
				System.out.println("WALL!");
			break;
		case 1:
			if(robotMidPointCol > 2){
				robotMidPointCol--;
				robot();
				grid[robotMidPointRow-1][robotMidPointCol+2].setBackground(EXPLORED);
				grid[robotMidPointRow][robotMidPointCol+2].setBackground(EXPLORED);
				grid[robotMidPointRow+1][robotMidPointCol+2].setBackground(EXPLORED);
			}
			else
				System.out.println("WALL!");
			break;
		case 2:
			if(robotMidPointRow > 2){
				robotMidPointRow--;
				robot();
				grid[robotMidPointRow+2][robotMidPointCol].setBackground(EXPLORED);
				grid[robotMidPointRow+2][robotMidPointCol+1].setBackground(EXPLORED);
				grid[robotMidPointRow+2][robotMidPointCol-1].setBackground(EXPLORED);
			}
			else
				System.out.println("WALL!");
			break;
		case 3:
			if(robotMidPointCol < 14){
				robotMidPointCol++;
				robot();
				grid[robotMidPointRow-1][robotMidPointCol-2].setBackground(EXPLORED);
				grid[robotMidPointRow][robotMidPointCol-2].setBackground(EXPLORED);
				grid[robotMidPointRow+1][robotMidPointCol-2].setBackground(EXPLORED);
			}
			else
				System.out.println("WALL!");
			break;
		}
	}
	
	//The robot orientation changes to its right
	private void spinRightAction(){
		robotOrientation++;
	    if (robotOrientation == 4) {
	    	robotOrientation = 0;
	    }
		shadeFront();
	}
	
	//The robot orientation changes to its left
	private void spinLeftAction(){
		robotOrientation--;
        if (robotOrientation == -1) {
        	robotOrientation = 3;
        }
		shadeFront();
	}
	
	private void setExplorationPathAction(){
		switch(robotOrientation){
		case 0: //NORTH
			if(grid[robotMidPointRow-2][robotMidPointCol-1].getBackground() != OBSTACLES)
				grid[robotMidPointRow-2][robotMidPointCol-1].setBackground(EXPLORED);
			
			if(grid[robotMidPointRow-2][robotMidPointCol].getBackground() != OBSTACLES)
				grid[robotMidPointRow-2][robotMidPointCol].setBackground(EXPLORED);
			
			if(grid[robotMidPointRow-2][robotMidPointCol+1].getBackground() != OBSTACLES)
				grid[robotMidPointRow-2][robotMidPointCol+1].setBackground(EXPLORED);
			break;
		case 1: //EAST
			if(grid[robotMidPointRow-1][robotMidPointCol+2].getBackground() != OBSTACLES)
				grid[robotMidPointRow-1][robotMidPointCol+2].setBackground(EXPLORED);
			
			if(grid[robotMidPointRow][robotMidPointCol+2].getBackground() != OBSTACLES)
				grid[robotMidPointRow][robotMidPointCol+2].setBackground(EXPLORED);
			
			if(grid[robotMidPointRow+1][robotMidPointCol+2].getBackground() != OBSTACLES)
				grid[robotMidPointRow+1][robotMidPointCol+2].setBackground(EXPLORED);
			break;
		case 2: //SOUTH
			if(grid[robotMidPointRow+2][robotMidPointCol-1].getBackground() != OBSTACLES)
				grid[robotMidPointRow+2][robotMidPointCol-1].setBackground(EXPLORED);
			if(grid[robotMidPointRow+2][robotMidPointCol].getBackground() != OBSTACLES)
				grid[robotMidPointRow+2][robotMidPointCol].setBackground(EXPLORED);
			if(grid[robotMidPointRow+2][robotMidPointCol+1].getBackground() != OBSTACLES)
				grid[robotMidPointRow+2][robotMidPointCol+1].setBackground(EXPLORED);
			break;
		case 3: //WEST
			if(grid[robotMidPointRow-1][robotMidPointCol-2].getBackground() != OBSTACLES)
				grid[robotMidPointRow-1][robotMidPointCol-2].setBackground(EXPLORED);
			if(grid[robotMidPointRow][robotMidPointCol-2].getBackground() != OBSTACLES)
				grid[robotMidPointRow][robotMidPointCol-2].setBackground(EXPLORED);
			if(grid[robotMidPointRow+1][robotMidPointCol-2].getBackground() != OBSTACLES)
				grid[robotMidPointRow+1][robotMidPointCol-2].setBackground(EXPLORED);
			break;
		}
	}
	
	private void shadeFront(){
		switch(robotOrientation){
			case 0: 
				grid[robotFrontRow][robotFrontCol].setBackground(ROBOT);
				robotFrontRow = robotMidPointRow - 1;
				robotFrontCol = robotMidPointCol;
				grid[robotFrontRow][robotFrontCol].setBackground(ROBOTFRONT);
				break;
			case 1:
				grid[robotFrontRow][robotFrontCol].setBackground(ROBOT);
				robotFrontRow = robotMidPointRow;
				robotFrontCol = robotMidPointCol + 1;
				grid[robotFrontRow][robotFrontCol].setBackground(ROBOTFRONT);
				break;
			case 2:
				grid[robotFrontRow][robotFrontCol].setBackground(ROBOT);
				robotFrontRow = robotMidPointRow + 1;
				robotFrontCol = robotMidPointCol;
				grid[robotFrontRow][robotFrontCol].setBackground(ROBOTFRONT);
				break;
			case 3:
				grid[robotFrontRow][robotFrontCol].setBackground(ROBOT);
				robotFrontRow = robotMidPointRow;
				robotFrontCol = robotMidPointCol - 1;
				grid[robotFrontRow][robotFrontCol].setBackground(ROBOTFRONT);
				break;
		}
	}
	
	public void moveForward(){
		queue.enqueueItem('f');
		setExplorationPath();
	}
	
	public void moveBackward(){
		queue.enqueueItem('b');
		setExplorationPath();
	}
	
	public void spinLeft(){
		queue.enqueueItem('l');
		setExplorationPath();
	}
	
	public void spinRight(){
		queue.enqueueItem('r');
		setExplorationPath();
	}
	
	public void setExplorationPath(){
		queue.enqueueItem('e');
	}
	
	public void setObstacles(int row, int col) {
		if(grid[row][col].getBackground() == DEFAULT)
			grid[row][col].setBackground(OBSTACLES);
	}
	
	//return true if cell is obstacle
	public boolean checkObstacle(int row, int col){
		if((grid[row][col].getBackground() == OBSTACLES) || (grid[row][col].getBackground() == OBSTACLESFOUND))
			return true;
		return false;
	}
	
	//cell display black; 
	public void addObstacles(int row, int col){
		if(grid[row][col].getBackground() == OBSTACLES)
			grid[row][col].setBackground(OBSTACLESFOUND);
		//if(grid[row][col].getBackground() == DEFAULT)
			//grid[row][col].setBackground(OBSTACLES);
	}
	
	//cell display default color
	public void removeObstacles(int row, int col){
		if(grid[row][col].getBackground() == OBSTACLES)
			grid[row][col].setBackground(DEFAULT);
	}
	
	private void clearRobot(int oldRow, int oldCol){
		grid[oldRow-1][oldCol-1].setBackground(DEFAULT);
		grid[oldRow][oldCol-1].setBackground(DEFAULT);
		grid[oldRow-1][oldCol].setBackground(DEFAULT);
		grid[oldRow-1][oldCol+1].setBackground(DEFAULT);
		grid[oldRow][oldCol].setBackground(DEFAULT);
		grid[oldRow+1][oldCol+1].setBackground(DEFAULT);
		grid[oldRow+1][oldCol].setBackground(DEFAULT);
		grid[oldRow][oldCol+1].setBackground(DEFAULT);
		grid[oldRow+1][oldCol-1].setBackground(DEFAULT);
	}
	
	//re-position the robot
	public void setRobotMidPoint(int row, int col){
		int curRow = robotMidPointRow;
		int curCol = robotMidPointCol;
		robotMidPointRow = row;
		robotMidPointCol = col;
		robot();
		clearRobot(curRow, curCol);
	}
	
	//return robot mid Point - Row
	public int getRobotMidPointRow(){
		return robotMidPointRow;
	}
	
	//return robot mid Point - Col
	public int getRobotMidPointCol(){
		return robotMidPointCol;
	}
	
	//return robot direction facing
	public int getRobotOrientation(){
		return robotOrientation;
	}
	
	//set robot orientation
	public void setRobotOrientation(int orientation){
		if(orientation < 4){
			robotOrientation = orientation;
			shadeFront();
		}
		else
			System.out.print("ERROR");
	}
	
	public void startTimer(){
		timer = new Timer(2000, new ActionListener() {
		      public void actionPerformed(ActionEvent evt) {
		    	  actionToBeTaken();
			}
		});
		timer.start(); 
	}
	
	public void stopTimer(){
		if(timer.isRunning())
			timer.stop(); 
		else
			System.out.println("Timer Not Started");
	}
	//ADD NEW FUNCTIONS BELOW. PLEASE COMMENT YOUR NAME ABOVE THE FUNCTION.
}
